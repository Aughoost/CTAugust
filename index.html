<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Chess Trainer Mode</title>

<link rel="stylesheet" href="css/chessboard-1.0.0.min.css">
<style>
body { font-family: Arial; margin: 20px; }
#main { display: flex; gap: 10px; align-items: flex-start; }
#board { width: 400px; }
#evalBarContainer { width: 24px; height: 400px; background: #ddd; border: 1px solid #999; position: relative; overflow: hidden; }
#evalBar { width: 100%; background: linear-gradient(to top, red 0%, red 50%, green 50%, green 100%); position: absolute; bottom: 0; height: 50%; transition: height 0.2s ease; }
#recommendations { width: 300px; font-family: monospace; font-size: 14px; background: #fafafa; border: 1px solid #ccc; padding: 10px; }
#recommendations h4 { margin: 0 0 5px 0; font-size: 16px; }
.pv-line { cursor: pointer; margin-bottom: 5px; color: #007bff; }
.pv-line:hover { text-decoration: underline; }
.player-move { font-weight: bold; margin-bottom: 2px; }
.blunder { color: red; }
.mistake { color: darkorange; }
.inaccuracy { color: orange; }
.good { color: green; }
.excellent { color: blue; }
.best { color: darkgreen; }
</style>
</head>
<body>

<h1>Chess Trainer</h1>
<div id="main">
  <div id="board"></div>

  <div id="eval-and-recs" style="display:flex; flex-direction: row; gap: 5px;">
    <div id="evalBarContainer">
      <div id="evalBar"></div>
    </div>

    <div id="recommendations">
      <h4>Move & Recommendation</h4>
      <div id="recContainer"></div>
    </div>
  </div>
</div>

<button id="newGameBtn">New Game</button>

<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script src="js/chessboard-1.0.0.min.js"></script>

<script>
const engine = new Worker("js/stockfish16.js");
const game = new Chess();
let board = Chessboard('board', { draggable: true, position: 'start', onDrop: onDrop });
const evalBar = document.getElementById("evalBar");
const recContainer = document.getElementById("recContainer");

let evalBeforeMove = 0;
let prevScore = 0;
let bestMoveForPlayer = null;
let lastPlayerMove = null;
let lastFENBeforeMove = null;
let awaitingBestMove = false;

// Update evaluation bar
function updateEvalBar(score) {
    const MAX = 5.0;
    let clamped = Math.max(Math.min(score, MAX), -MAX);
    let percent = ((clamped + MAX) / (2*MAX))*100;
    evalBar.style.height = percent + "%";
}

// Classify move
function classifyMove(before, after, turn) {
    const diff = (turn === 'w') ? after - before : before - after;
    if (diff < -1.5) return "Blunder";
    if (diff < -0.5) return "Mistake";
    if (diff < -0.2) return "Inaccuracy";
    if (diff < 0.2) return "Good";
    if (diff < 0.5) return "Excellent";
    return "Best";
}

function moveClass(classification) {
    switch(classification) {
        case "Blunder": return "blunder";
        case "Mistake": return "mistake";
        case "Inaccuracy": return "inaccuracy";
        case "Good": return "good";
        case "Excellent": return "excellent";
        case "Best": return "best";
        default: return "";
    }
}

// Convert UCI to SAN given a FEN
function uciToSan(uci, fen) {
    const tmp = new Chess(fen);
    const moves = tmp.moves({ verbose: true });
    for (let m of moves) {
        if ((m.from + m.to + (m.promotion || "")) === uci) return m.san;
    }
    return uci;
}

// Ask engine for best move
function askEngine(fen, multipv = 1, depth = 12) {
    engine.postMessage("position fen " + fen);
    engine.postMessage("setoption name MultiPV value " + multipv);
    engine.postMessage("go depth " + depth);
}

// Get best move for player BEFORE move
function getBestMoveForPlayer(fen) {
    bestMoveForPlayer = null;
    awaitingBestMove = true;
    engine.postMessage("position fen " + fen);
    engine.postMessage("setoption name MultiPV value 1");
    engine.postMessage("go depth 12");
}

// Handle drop
function onDrop(source, target) {
    const move = game.move({ from: source, to: target, promotion: 'q' });
    if (!move) return "snapback";

    lastPlayerMove = move;
    board.position(game.fen());

    // Ask engine for both evaluation AND best move for next recommendation
    askEngineForRecommendation(game.fen(), move.color);
}

function askEngineForRecommendation(fen, turn) {
    engine.postMessage("position fen " + fen);
    engine.postMessage("setoption name MultiPV value 1");
    engine.postMessage("go depth 12");
    awaitingBestMove = true;
    lastFENBeforeMove = fen;
}



// Render player move + recommended move
function renderRecommendation() {
    recContainer.innerHTML = "";
    if (!lastPlayerMove || !bestMoveForPlayer) return;

    const classification = classifyMove(evalBeforeMove, prevScore, lastPlayerMove.color);
    const moveDiv = document.createElement("div");
    moveDiv.className = "player-move " + moveClass(classification);
    moveDiv.textContent = lastPlayerMove.san + " - " + classification;
    recContainer.appendChild(moveDiv);

    const recDiv = document.createElement("div");
    recDiv.className = "pv-line";
    recDiv.textContent = "Recommended move: " + bestMoveForPlayer;
    recDiv.onclick = () => {
        game.undo();
        game.move(bestMoveForPlayer, { sloppy: true });
        board.position(game.fen());
        lastPlayerMove = null;
        askEngine(game.fen(), 1);
    };
    recContainer.appendChild(recDiv);
}

// Engine output
engine.onmessage = function(event) {
    const line = event.data;
    if (!line) return;

    // Parse score
    const scoreMatch = line.match(/\bscore (\w+) (-?\d+)/);
    if (scoreMatch) {
        const type = scoreMatch[1], val = parseInt(scoreMatch[2]);
        let score = (type === "cp") ? val / 100 : (val > 0 ? 100 : -100);
        if (game.turn() === "b") score = -score;
        prevScore = score;
        updateEvalBar(score);
    }

    // Parse PV for recommended move
    if (awaitingBestMove && line.includes("pv")) {
        const pvMatch = line.match(/\bpv (([a-h][1-8][a-h][1-8][qrbn]? ?)+)/);
        if (pvMatch) {
            const uci = pvMatch[1].trim().split(" ")[0];
            bestMoveForPlayer = uciToSan(uci, lastFENBeforeMove);
            awaitingBestMove = false;
            renderRecommendation();
        }
    }
};

// New Game
document.getElementById("newGameBtn").onclick = function() {
    game.reset();
    board.position("start");
    recContainer.innerHTML = "";
    prevScore = 0;
    evalBeforeMove = 0;
    lastPlayerMove = null;
    bestMoveForPlayer = null;
    awaitingBestMove = false;
    engine.postMessage("ucinewgame");
    askEngine(game.fen(), 1);
};

// Initialize engine
engine.postMessage("uci");
engine.postMessage("isready");
askEngine(game.fen(), 1);
</script>
</body>
</html>
